#include <Python.h>
#include <seccomp.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/resource.h>
#include <ucontext.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "sbcontext.h"

#ifndef SYS_SECCOMP
#define SYS_SECCOMP 1
#endif

// fds for our input and output, opened by the parent proc
#define PIPEIN 3
#define PIPEOUT 4

// default resource usage limits by sandbox, 64 MiB of memory and 5 seconds of cpu time
// these can be modified (increased or decreased) by argv params
#define DEF_MEMORY 67108864
#define DEF_CPU 5

// marshal types, should be kept in-sync with Constants.php
// TYPE_NONE is a special case indicating we should not encode a type value
#define TYPE_NONE (-1)
#define TYPE_STR 0
#define TYPE_INT 1
#define TYPE_UINT 2
#define TYPE_FLT 3

void trampoline(int signal, siginfo_t *info, void *context);
ssize_t writedata(void *buf, size_t count);
ssize_t readdata(void *buf, size_t count);
void stream_numargs(uint8_t numargs);
void stream_data(void *buf, uint32_t count, signed char type);
int32_t read_response(int *set_errno);
void read_stat_response(struct stat *buf);

int main(int argc, char *argv[])
{
	int ret = -1;
	unsigned long mem_limit, cpu_limit;
	struct rlimit rl;
	scmp_filter_ctx ctx = NULL;
	wchar_t *program = NULL;
	size_t programlen = 0;
	struct sigaction sa;
	sigset_t mask;
	FILE *mainpy = NULL;

	// verify we have all necessary args and that fds 3 and 4 have been opened for us
	if (argc < 4) {
		fprintf(stderr, "Usage: %s path_to_python memory_limit_bytes cpu_limit_secs\n", argv[0]);
		goto cleanup;
	}

	ret = fcntl(3, F_GETFD);
	if (ret < 0) {
		fprintf(stderr, "%s: Must be run as a child process with fds 3 and 4 opened.\n", argv[0]);
		goto cleanup;
	}
	
	ret = fcntl(4, F_GETFD);
	if (ret < 0) {
		fprintf(stderr, "%s: Must be run as a child process with fds 3 and 4 opened.\n", argv[0]);
		goto cleanup;
	}

	mem_limit = strtoul(argv[2], NULL, 10);
	cpu_limit = strtoul(argv[3], NULL, 10);

	if (mem_limit == 0)
		mem_limit = DEF_MEMORY;

	if (cpu_limit == 0)
		cpu_limit = DEF_CPU;

	// set resource limits, we limit our address space and cpu, and disable core dumps
	rl.rlim_cur = mem_limit;
	rl.rlim_max = mem_limit;
	ret = setrlimit(RLIMIT_AS, &rl);
	if (ret < 0)
		goto cleanup;

	rl.rlim_cur = 0;
	rl.rlim_max = 0;
	ret = setrlimit(RLIMIT_CORE, &rl);
	if (ret < 0)
		goto cleanup;

	rl.rlim_cur = cpu_limit;
	rl.rlim_max = cpu_limit;
	ret = setrlimit(RLIMIT_CPU, &rl);
	if (ret < 0)
		goto cleanup;

	// set up our SIGSYS handler; any disallowed syscalls are trapped by this handler
	// if this ends up getting a SIGSYS that wasn't generated by seccomp, it exits the program
	sigfillset(&mask); // block all other signals while ours is running
	sa.sa_sigaction = trampoline;
	sa.sa_mask = mask;
	sa.sa_flags = SA_SIGINFO;
	sigaction(SIGSYS, &sa, NULL);

	// set up seccomp, we allow the following syscalls:
	// read() - fd 3 only
	// write() - fd 4 only
	// sigreturn(), rt_sigreturn() - needed for signal handlers
	// brk(), mmap(), mmap2(), mremap(), munmap() - needed for memory allocation (malloc/free)
	// exit(), exit_group() - so program can terminate
	ctx = seccomp_init(SCMP_ACT_TRAP);
	if (ctx == NULL)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 1, SCMP_A0(SCMP_CMP_EQ, PIPEIN));
	if (ret < 0)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1, SCMP_A0(SCMP_CMP_EQ, PIPEOUT));
	if (ret < 0)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(sigreturn), 0);
	if (ret < 0)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);
	if (ret < 0)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
	if (ret < 0)
		goto cleanup;

	ret = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
	if (ret < 0)
		goto cleanup;

	ret = seccomp_load(ctx);
	if (ret < 0)
		goto cleanup;

	// initialize python interpreter -- this is initialized AFTER sandbox is set up
	// so that the python path can be faked (in essence, this allows for the parent proc
	// to implement a pseudo-chroot by specifying a virtual path to python).
	// This also ensures that anything done as part of the python initialization cannot
	// be used as a means to break out of the sandbox.
	programlen = mbstowcs(NULL, argv[1], 0) + 1;
	program = (wchar_t *)malloc(programlen * sizeof(wchar_t));
	if (mbstowcs(program, argv[1], programlen) == (size_t)-1) {
		ret = -1;
		fprintf(stderr, "%s: Cannot decode python path.\n", argv[0]);
		goto cleanup;
	}

	Py_SetProgramName(program);
	Py_Initialize();

	// init the python side of things by populating libraries, etc.
	// We expect that the parent proc provides a "main.py" file somewhere which contains
	// this initialization code, as well as the code to run whatever the user wanted.
	mainpy = fopen("main.py", "r");
	if (mainpy == NULL) {
		ret = errno;
		fprintf(stderr, "%s: Cannot open main.py.\n", argv[0]);
		goto cleanup;
	}

	// this closes mainpy after completion so we don't need to fclose it in cleanup
	ret = PyRun_SimpleFile(mainpy, "main.py");

cleanup:
	Py_Finalize();
	if (program != NULL)
		free(program);
	seccomp_release(ctx);
	return -ret;
}

void trampoline(int signal, siginfo_t *siginfo, void *void_ctx)
{
	int old_errno = errno;
	int32_t ret = 0, buflen;
	const char *name;
	uint32_t namelen;

	// SB_P*(ctx) can be used to get first 6 params passed to syscall (P1-P6)
	ucontext_t *ctx = (ucontext_t *)void_ctx;

	if (signal != SIGSYS || siginfo->si_code != SYS_SECCOMP) {
		// signal was not generated by seccomp, so quit our process
		exit(-SIGSYS);
	}

	// stream syscall and params over to parent proc and then read the reply
	// we need to do this on a per-syscall basis in order to properly capture params
	// we also transform the syscall int into a string name for increased portability
	if (siginfo->si_syscall >= nsyscalls) {
		// invalid or unknown syscall number
		exit(-SIGSYS);
	}

	name = syscalls[siginfo->si_syscall];
	namelen = (uint32_t)strlen(name);

	// serialization format is simple: each piece of data is tagged with a 32-bit length:
	// syscall_name_len[4] syscall_name[*] num_arguments[1] argument_len[4] argument[*]...
	// all integers are passed in native byte order
	stream_data((void *)name, namelen, TYPE_NONE);

	switch (siginfo->si_syscall) {
		case SCMP_SYS(read):
			// ssize_t read(int fd, void *buf, size_t count)
			// note: we do not stream buf to the parent. Parent replies with the return
			// value of read followed by that many bytes of data to be put into buf.
			stream_numargs(2);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)&SB_P3(ctx), sizeof(size_t), TYPE_UINT);
			ret = buflen = read_response(&old_errno);
			if (buflen > 0 && buflen <= (size_t)SB_P3(ctx)) {
				ret = readdata((void *)SB_P2(ctx), buflen);
				if (ret == -1) {
					exit(errno);
				} else if (ret == -2 || ret != buflen) {
					exit(-SIGPIPE);
				}
			}
			break;
		case SCMP_SYS(write):
			// ssize_t write(int fd, const void *buf, size_t count)
			// note: we stream buf to the parent instead of giving the pointer address
			// as such, streaming the count separately is pointless, so we do not do that
			stream_numargs(2);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)SB_P2(ctx), (uint32_t)SB_P3(ctx), TYPE_UINT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(open):
			// int open(const char *pathname, int flags, mode_t mode)
			stream_numargs(3);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			stream_data((void *)&SB_P2(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)&SB_P3(ctx), sizeof(mode_t), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(creat):
			// int creat(const char *pathname, mode_t mode)
			stream_numargs(2);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			stream_data((void *)&SB_P2(ctx), sizeof(mode_t), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(openat):
			// int openat(int dirfd, const char *pathname, int flags, mode_t mode)
			stream_numargs(4);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)SB_P2(ctx), strlen((const char *)SB_P2(ctx)), TYPE_STR);
			stream_data((void *)&SB_P3(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)&SB_P4(ctx), sizeof(mode_t), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(close):
			// int close(int fd)
			stream_numargs(1);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(stat):
			// int stat(const char *pathname, struct stat *buf)
			// parent streams the following 13 fields in order upon success (all 4-byte ints)
			// st_dev, st_ino, st_mode, st_nlink, st_uid, st_gid, st_rdev, st_size,
			// st_blksize, st_blocks, st_atim.tv_sec, st_mtim.tv_sec, st_ctim.tv_sec
			stream_numargs(1);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			ret = read_response(&old_errno);
			if (ret == 0) {
				read_stat_response((struct stat *)SB_P2(ctx));
			}
			break;
		case SCMP_SYS(lstat):
			// int lstat(const char *pathname, struct stat *buf)
			stream_numargs(1);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			ret = read_response(&old_errno);
			if (ret == 0) {
				read_stat_response((struct stat *)SB_P2(ctx));
			}
			break;
		case SCMP_SYS(fstat):
			// int fstat(int fd, struct stat *buf)
			stream_numargs(1);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			ret = read_response(&old_errno);
			if (ret == 0) {
				read_stat_response((struct stat *)SB_P2(ctx));
			}
			break;
		case SCMP_SYS(access):
			// int access(const char *pathname, int mode)
			stream_numargs(2);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			stream_data((void *)&SB_P2(ctx), sizeof(int), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(faccessat):
			// int faccessat(int dirfd, const char *pathname, int mode, int flags)
			stream_numargs(4);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)SB_P2(ctx), strlen((const char *)SB_P2(ctx)), TYPE_STR);
			stream_data((void *)&SB_P3(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)&SB_P4(ctx), sizeof(int), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(unlink):
			// int unlink(const char *pathname)
			stream_numargs(1);
			stream_data((void *)SB_P1(ctx), strlen((const char *)SB_P1(ctx)), TYPE_STR);
			ret = read_response(&old_errno);
			break;
		case SCMP_SYS(unlinkat):
			// int unlinkat(int dirfd, const char *pathname, int flags)
			stream_numargs(3);
			stream_data((void *)&SB_P1(ctx), sizeof(int), TYPE_INT);
			stream_data((void *)SB_P2(ctx), strlen((const char *)SB_P2(ctx)), TYPE_STR);
			stream_data((void *)&SB_P3(ctx), sizeof(int), TYPE_INT);
			ret = read_response(&old_errno);
			break;
		default:
			stream_numargs(0);
			exit(EINVAL);
	}

	// before returning, restore errno and set the return register
	errno = old_errno;
	SB_RET(ctx) = (greg_t)ret;
}

void stream_numargs(uint8_t numargs)
{
	ssize_t ret;

	ret = writedata(&numargs, 1);
	if (ret == -1) {
		exit(errno);
	} else if (ret == -2) {
		exit(-SIGPIPE);
	}
}

void stream_data(void *buf, uint32_t count, signed char type)
{
	ssize_t ret;

	if (type != TYPE_NONE) {
		ret = writedata(&type, 1);
		if (ret == -1) {
			exit(errno);
		} else if (ret == -2) {
			exit(-SIGPIPE);
		}
	}

	ret = writedata(&count, 4);
	if (ret == -1) {
		exit(errno);
	} else if (ret == -2) {
		exit(-SIGPIPE);
	}

	ret = writedata(buf, count);
	if (ret == -1) {
		exit(errno);
	} else if (ret == -2) {
		exit(-SIGPIPE);
	}
}

int32_t read_response(int *set_errno)
{
	int32_t buf;
	ssize_t ret;

	ret = readdata(&buf, sizeof(int32_t));
	if (ret == -1) {
		exit(errno);
	} else if (ret == -2) {
		exit(-SIGPIPE);
	}

	if (buf == -1 && set_errno != NULL) {
		ret = readdata(&buf, sizeof(int32_t));
		if (ret == -1) {
			exit(errno);
		} else if (ret == -2) {
			exit(-SIGPIPE);
		}

		*set_errno = buf;
		return -1;
	}

	return buf;
}

void read_stat_response(struct stat *buf)
{
	uint32_t buf4 = 0;
	ssize_t ret;

	ret = readdata(&buf4, 4);
	buf->st_dev = (dev_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_ino = (ino_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_mode = (mode_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_nlink = (nlink_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_uid = (uid_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_gid = (gid_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_rdev = (dev_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_size = (off_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_blksize = (blksize_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_blocks = (blkcnt_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_atim.tv_sec = (time_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_mtim.tv_sec = (time_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}

	ret = readdata(&buf4, 4);
	buf->st_ctim.tv_sec = (time_t)buf4;
	if (ret == -1) {
		exit(errno);
	} else if (ret != 4) {
		exit(-SIGPIPE);
	}
}

// helper function to write to pipeout until all count data has been written
ssize_t writedata(void *buf, size_t count)
{
	ssize_t ret = 0,
			prev = -1,
			off = 0;

	do {
		ret = write(PIPEOUT, buf + off, count - off);
		if (ret == -1)
			return -1;
		if (ret == 0 && prev == 0)
			return -2; 
		prev = ret;
		off += ret;
	} while (count - off > 0);

	return off;
}

// helper function to read from pipein until all count data has been read
ssize_t readdata(void *buf, size_t count)
{
	ssize_t ret = 0,
			prev = -1,
			off = 0;

	do {
		ret = read(PIPEIN, buf + off, count - off);
		if (ret == -1)
			return -1;
		if (ret == 0 && prev == 0)
			return -2;
		prev = ret;
		off += ret;
	} while (count - off > 0);

	return off;
}
